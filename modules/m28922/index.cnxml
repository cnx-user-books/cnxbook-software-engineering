<document xmlns="http://cnx.rice.edu/cnxml" xmlns:md="http://cnx.rice.edu/mdml">
  <title>Introduction</title>
  <metadata>
  <md:content-id>m28922</md:content-id><md:title>Introduction</md:title>
  <md:abstract>The objective of this session is to introduce the subject of software engineering. When you have read this session you will understand what software engineering is and why it is important, know the answers to key questions which provide an introduction to software engineering, understand ethical and professional issues which are important for software engineers.</md:abstract>
  <md:uuid>b9eef8b6-24c3-4982-9ec0-cff0775bc4bb</md:uuid>
</metadata>

<content>
    <section id="id-874453661616">
      <title>Introduction</title>
      <para id="id10163416">Virtually all countries now depend on complex computer-based systems. More and more products incorporate computers and controlling software in some form. The software in these systems represents a large and increasing proportion of the total system costs. Therefore, producing software in a cost-effective way is essential for the functioning of national and international economies.</para>
      <para id="id6414431">Software engineering is an engineering discipline whose goal is the cost-effective development of software systems. Software is abstract and intangible. It is not constrained by materials, governed by physical laws or by manufacturing processes. In some ways, this simplifies software engineering as there are no physical limitations on the potential of software. In other ways, however, this lack of natural constraints means that software can easily become extremely complex and hence very difficult to understand.</para>
      <para id="id12656470">Software engineering is still a relatively young discipline. The notion of ‘software engineering’ was first proposed in 1968 at a conference held to discuss what was then called the ‘software crisis’. This software crisis resulted directly from the introduction of powerful, third generation computer hardware. Their power made hitherto unrealisable computer applications a feasible proposition. The resulting software was orders of magnitude larger and more complex than previous software systems.</para>
      <para id="id6065641">Early experience in building these systems showed that an informal approach to software development was not good enough. Major projects were sometimes years late. They cost much more than originally predicted, were unreliable, difficult to maintain and performed poorly. Software development was in crisis. Hardware costs were tumbling whilst software costs were rising rapidly. New techniques and methods were needed to control the complexity inherent in large software systems. </para>
      <para id="id13441944">These techniques have become part of software engineering and are now widely although not universally used. However, there are still problems in producing complex software which meets user expectations, is delivered on time and to budget. Many software projects still have problems and this has led to some commentators (Pressman, 1997) suggesting that software engineering is in a state of chronic affliction.</para>
      <para id="id13125011">As our ability to produce software has increased so too has the complexity of the software systems required. New technologies resulting from the convergence of computers and communication systems place new demands on software engineers. For this reason and because many companies do not apply software engineering techniques effectively, we still have problems. Things are not as bad as the doomsayers suggest but there is clearly room for improvement.</para>
      <para id="id10088124">We have made tremendous progress since 1968 and that the development of software engineering has markedly improved our software. We have a much better understanding of the activities involved in software development. We have developed effective methods of software specification, design and implementation. New notations and tools reduce the effort required to produce large and complex systems.</para>
      <para id="id9170186">Software engineers can be rightly proud of their achievements. Without complex software we would not have explored space, would not have the Internet and modern telecommunications, and all forms of travel would be more dangerous and expensive. Software engineering has contributed a great deal in its short lifetime and I am convinced that, as the discipline matures, its contributions in the 21st century will be even greater.</para>
      <section id="id-014340902528">
        <title>What is software?</title>
        <para id="id13841770">Many people equate the term software with computer programs. In fact, this is too restrictive a view. Software is not just the programs but also all associated documentation and configuration data which is needed to make these programs operate correctly. A software system usually consists of a number of separate programs, configuration files which are used to set up these programs, system documentation which describes the structure of the system and user documentation which explains how to use the system and, for software products, web sites for users to download recent product information.</para>
        <para id="id12999616">Software engineers are concerned with developing software products i.e. software which can be sold to a customer. There are two types of software product: </para>
        <para id="id14467540">1. Generic products: These are stand-alone systems which are produced by a development organisation and sold on the open market to any customer who is able to buy them. Sometimes they are referred to as shrink-wrapped software. Examples of this type of product include databases, word processors, drawing packages and project management tools. </para>
        <para id="id13494576">2. Bespoke (or customised) products: These are systems which are commissioned by a particular customer. The software is developed specially for that customer by a software contractor. Examples of this type of software include control systems for electronic devices, systems written to support a particular business process and air traffic control systems.</para>
        <para id="id13310321">An important difference between these different types of software is that, in generic products, the organisation which develops the software controls the software specification. For custom products, the specification is usually developed and controlled by the organisation who are buying the software. The software developers must work to that specification.</para>
      </section>
      <section id="id-37628115845">
        <title>What is software engineering?</title>
        <para id="id13346883">Software engineering is an engineering discipline which is concerned with all aspects of software production from the early stages of system specification through to maintaining the system after it has gone into use. In this definition, there are two key phrases:</para>
        <para id="id8430026">1. Engineering discipline: Engineers make things work. They apply theories, methods and tools where these are appropriate but they use them selectively and always try to discover solutions to problems even when there are no applicable theories and methods to support them. Engineers also recognise that they must work to organisational and financial constraints so they look for solutions within these constraints.</para>
        <para id="id13570090">2. All aspects of software production: Software engineering is not just concerned with the technical processes of software development but also with activities such as software project management and with the development of tools, methods and theories to support software production.</para>
        <para id="id12376890">In general, software engineers adopt a systematic and organised approach to their work as this is often the most effective way to produce high-quality software. However, engineering is all about selecting the most appropriate method for a set of circumstances and a more creative, informal approach to development may be effective in some circumstances. Informal development is particularly appropriate for the development of web-based e-commerce systems which requires a blend of software and graphical design skills.</para>
      </section>
      <section id="id-504190610438">
        <title>What’s the difference between software engineering and computer science?</title>
        <para id="id7855704">Essentially, computer science is concerned about theories and methods which underlie computers and software systems whereas software engineering is concerned with the practical problems of producing software. Some knowledge of computer science is essential for software engineers in the same way that some knowledge of physics is essential for electrical engineers.</para>
        <para id="id13519214">Ideally, all of software engineering should be underpinned by theories of computer science but in reality this is not the case. Software engineers must often use ad hoc approaches to develop the software. Elegant theories of computer science are cannot always be applied to real, complex problems which require a software solution.</para>
      </section>
      <section id="id-154971290169">
        <title>What is the difference between software engineering and system engineering?</title>
        <para id="id13976510">System engineering or, more precisely, computer-based system engineering is concerned with all aspects of the development and evolution of complex systems where software plays a major role. System engineering is therefore concerned with hardware development, policy and process design and system deployment as well as software engineering. System engineers are involved in specifying the system, defining its overall architecture and then integrating the different parts to create the finished system. They are less concerned with the engineering of the system components (hardware, software, etc.).</para>
        <para id="id2952553">System engineering is an older discipline than software engineering. People have been specifying and assembling complex industrial systems such as aircraft and chemical plants for more than 100 years. However, as the percentage of software in systems has increased, software engineering techniques such as use-case modelling, configuration management, etc. are being used in the systems engineering process. </para>
      </section>
      <section id="id-184917390809">
        <title>What is a software process?</title>
        <para id="id10435271">A software process is the set of activities and associated results which produce a software product. These activities are mostly carried out by software engineers. There are four fundamental process activities which are common to all software processes. These activities are:</para>
        <para id="id10387208">1. Software specification: The functionality of the software and constraints on its operation must be defined.</para>
        <para id="id8070603">2. Software development: The software to meet the specification must be produced.</para>
        <para id="id6539338">3. Software validation The software must be validated to ensure that it does what the customer wants.</para>
        <para id="id5720280">4. Software evolution: The software must evolve to meet changing customer needs.</para>
        <para id="id7496498">Different software processes organise these activities in different ways and are described at different levels of detail. The timing of the activities varies as does the results of each activity. Different organisations may use different processes to produce the same type of product. However, some processes are more suitable than others for some types of application. If an inappropriate process is used, this will probably reduce the quality or the usefulness of the software product to be developed.</para>
      </section>
      <section id="id-951669917143">
        <title>What is a software process model?</title>
        <para id="id12811431">A software process model is a simplified description of a software process which is presented from a particular perspective. Models, by their very nature, are simplifications so a software process model is an abstraction of the actual process which is being described. Process models may include activities which are part of the software process, software products and the roles of people involved in software engineering. Some examples of the types of software process model which may be produced are:</para>
        <para id="id11709333">1. A workflow model: This shows the sequence of activities in the process along with their inputs, outputs and dependencies. The activities in this model represent human actions.</para>
        <para id="id13559885">2. A dataflow or activity model: This represents the process as a set of activities each of which carries out some data transformation. It shows how the input to the process such as a specification is transformed to an output such as a design. The activities here may be at a lower-level than activities in a workflow model. They may represent transformations carried out by people or by computers.</para>
        <para id="id9245611">3. A role/action model: This represents the roles of the people involved in the software process and the activities for which they are responsible. There are a number of different general models or paradigms of software development:</para>
        <list id="id13350540" list-type="bulleted">
          <item>The waterfall approach: This takes the above activities and represents them as separate process phases such as requirements specification, software design, implementation, testing and so on. After each stage is defined it is ‘signed-off’ and development goes on to the following stage.</item>
          <item>Evolutionary development: This approach interleaves the activities of specification, development and validation. An initial system is rapidly developed from very abstract specifications. This is then refined with customer input to produce a system which satisfies the customer’s needs.</item>
        </list>
      </section>
      <section id="id-869583323082">
        <title>What are the costs of software engineering?</title>
        <para id="id7219871">There is no simple answer to this question as the precise distribution of costs across the software process depends on the process used and the type of software which is being developed. If we take the total cost of developing a complex software system as 100 cost units, the distribution of these cost units is 25 for specification, 25 for design, 25 for development and the rest for intergration and testing.</para>
        <para id="id12483244">This cost distribution holds where the costs of specification, design, implementation and integration are measured separately. Notice that system integration and testing is the most expensive development activity. </para>
        <para id="id8456861">The evolution costs for generic software products are particularly hard to estimate. In many cases, there is little formal evolution of a product. Once a version of the product has been released, work starts on the next release and, for marketing reasons, this is likely to be presented as a new (but compatible) product rather than a modified version of a product which the user has already bought. Therefore, the evolution costs are not assessed separately as they are in customised software but are simply the development costs for the next version of the system.</para>
      </section>
      <section id="id-860683248458">
        <title>What are software engineering methods?</title>
        <para id="id2989153">A software engineering method is a structured approach to software development whose aim is to facilitate the production of high-quality software in a cost-effective way. Methods such as Structured Analysis (DeMarco, 1978) and JSD (Jackson, 1983) were first developed in the 1970s. These methods attempted to identify the basic functional components of a system and function-oriented methods are still widely used. In the 1980s and 1990s, these function-oriented methods were supplemented by object-oriented methods such as those proposed by Booch (Booch, 1994) and Rumbaugh (Rumbaugh, Blaha et al., 1991). These different approaches have now been integrated into a single unified approach built around the Unified Modeling Language (UML) (Fowler and Scott, 1997) (Booch, Rumbaugh et al., 1999; Rumbaugh, Jacobson et al., 1999; Rumbaugh, Jacobson et al., 1999).</para>
        <para id="id13600234">All methods are based on the idea of developing models of a system which may be represented graphically and using these models as a system specification or design. </para>
        <para id="id8223374">There is no ideal method and different methods have different areas where they are applicable. For example, object-oriented methods are often appropriate for interactive systems but not for systems with stringent real-time requirements.</para>
      </section>
      <section id="id-911493755606">
        <title>What is CASE?</title>
        <para id="id14395275">The acronym CASE stands for Computer-Aided Software Engineering. It covers a wide range of different types of program which are used to support software process activities such as requirements analysis, system modelling, debugging and testing. </para>
        <para id="id13656000">All methods now come with associated CASE technology such as editors for the notations used in the method, analysis modules which check the system model according to the method rules and report generators to help create system documentation. The CASE tools may also include a code generator which automatically generates source code from the system model and some process guidance which gives advice to the software engineer on what to do next.</para>
        <para id="id12931460">This type of CASE tool, aimed at supporting analysis and design, is sometimes called an upper-CASE tool because it supports early phases of the software process. By contrast, CASE tools which are designed to support implementation and testing such as debuggers, program analysis systems, test case generators and program editors are sometimes called lower-CASE tools.</para>
      </section>
      <section id="id-235596934851">
        <title>What are the attributes of good software?</title>
        <para id="id12404146">As well as the services which it provides, software products have a number of other associated attributes which reflect the quality of that software. These attributes are not directly concerned with what the software does, Rather, they reflect its behaviour while it is executing and the structure and organisation of the source program and associated documentation. Examples of these attributes (sometimes called non-functional attributes) are the software’s response time to a user query and the understandability of the program code.</para>
        <para id="id7209422">The specific set of attributes which you might expect from a software system obviously depends on its application. Therefore, a banking system must be secure, an interactive game must be responsive, a telephone switching system must be reliable, etc. </para>
      </section>
      <section id="id-532370391465">
        <title>What are the key challenges facing software engineering?</title>
        <para id="id13961334">Software engineering in the 21st century faces three key challenges:</para>
        <para id="id12092699">1. The legacy challenge: The majority of software systems which are in use today were developed many years ago yet they perform critical business functions. The legacy challenge is the challenge of maintaining and updating this software in such a way that excessive costs are avoided and essential business services continue to be delivered.</para>
        <para id="id10998916">2. The heterogeneity challenge: Increasingly, systems are required to operate as distributed systems across networks that include different types of computer and with different kinds of support systems. The heterogeneity challenge is the challenge of developing techniques to build dependable software which is flexible enough to cope with this heterogeneity.</para>
        <para id="id6410108">3. The delivery challenge: Many traditional software engineering techniques are time-consuming. The time they take is required to achieve software quality. However, businesses today must be responsive and change very rapidly. Their supporting software must change equally rapidly. The delivery challenge is the challenge of shortening delivery times for large and complex systems without compromising system quality.</para>
        <para id="id3558762">Of course, these are not independent. For example, it may be necessary to make rapid changes to a legacy system to make it accessible across a network. To address these challenges we will need new tools and techniques as well as innovative ways of combining and using existing software engineering methods. </para>
      </section>
    </section>
    <section id="id-464953913922">
      <title>Professional and ethical responsibility</title>
      <para id="id8455394">Like other engineers, software engineers must accept that their job involves wider responsibilities than simply the application of technical skills. Their work is carried out within a legal and social framework. Software engineering is obviously bounded by local, national and international laws. Software engineers must behave in an ethical and morally responsible way if they are to be respected as professionals.</para>
      <para id="id5935569">It goes without saying that engineers should uphold normal standards of honesty and integrity. They should not use their skills and abilities to behave in a dishonest way or in a way that will bring disrepute to the software engineering profession. However, there are areas where standards of acceptable behaviour are not bounded by laws but by the more tenuous notion of professional responsibility.</para>
      <para id="id10201065">Some of these are:</para>
      <para id="id10201068">1. Confidentiality: Engineers should normally respect the confidentiality of their employers or clients irrespective of whether or not a formal confidentiality agreement has been signed.</para>
      <para id="id3561576">2. Competence: Engineers should not misrepresent their level of competence. They should not knowingly accept work which is outwith their competence.</para>
      <para id="id12922201">3. Intellectual property rights: Engineers should be aware of local laws governing the use of intellectual property such as patents, copyright, etc. They should be careful to ensure that the intellectual property of employers and clients is protected.</para>
      <para id="id10511022">4. Computer misuse: Software engineers should not use their technical skills to misuse other people’s computers. Computer misuse ranges from relatively trivial (game playing on an employer’s machine, say) to extremely serious (dissemination of viruses).</para>
      <para id="id9999687">In this respect, professional societies and institutions have an important role to play. Organisations such as the ACM, the IEEE (Institute of Electrical and Electronic Engineers) and the British Computer Society publish a code of professional conduct or code of ethics. Members of these organisations undertake to follow that code when they sign up for membership. These codes of conduct are generally concerned with fundamental ethical behaviour.</para>
      <para id="id8998176">The ACM and the IEEE have cooperated to produce a joint code of ethics and professional practice. The rationale behind this code is summarised in the first two paragraphs of the longer form:</para>
      <para id="id11773927">
        <cite><cite-title>Computers have a central and growing role in commerce, industry, government, medicine, education, entertainment and society at large. Software engineers are those who contribute by direct participation or by teaching, to the analysis, specification, design, development, certification, maintenance and testing of software systems. Because of their roles in developing software systems, software engineers have significant opportunities to do good or cause harm, to enable others to do good or cause harm, or to influence others to do good or cause harm. To ensure, as much as possible, that their efforts will be used for good, software engineers must commit themselves to making software engineering a beneficial and respected profession. In accordance with that commitment, software engineers shall adhere to the following Code of Ethics</cite-title></cite>
      </para>
      <para id="id8791626">
        <cite><cite-title>and Professional Practice.</cite-title></cite>
      </para>
      <para id="id13233805">
        <cite><cite-title>The Code contains eight Principles related to the behaviour of and decisions made by professional software engineers, including practitioners, educators, managers, supervisors and policy makers, as well as trainees and students of the profession. The Principles identify the ethically responsible relationships in which individuals, groups, and organizations participate and the primary obligations within these relationships. The Clauses of each Principle are illustrations of some of the obligations included in these relationships. These obligations are founded in the software engineer’s humanity, in special care owed to people affected by the work of software engineers, and the unique elements of the practice of software engineering. The Code prescribes these as obligations of anyone claiming to be or aspiring to be a software engineer.</cite-title></cite>
      </para>
      <para id="id8238031">In any situation where different people have different views and objectives you are likely to be faced with ethical dilemmas. For example, if you disagree, in principle, with the policies of more senior management in the company, how should you react? Clearly, this depends on the particular individuals and the nature of the disagreement. Is it best to argue a case for your position from within the organisation or to resign in principle? If you feel that there are problems with a software project, when do you reveal these to management? If you discuss these while they are just a suspicion, you may be over-reacting to a situation; if you leave it too late, it may be impossible to resolve the difficulties.</para>
      <para id="id12380899">Such ethical dilemmas face all of us in our professional lives and, fortunately, in most cases they are either relatively minor or can be resolved without too much difficulty. Where they cannot be resolved, the engineer is faced with, perhaps, another problem. The principled action may be to resign from their job but this may well affect others such as their partner or their children.</para>
      <para id="id8376618">A particularly difficult situation for professional engineers arises when their employer acts in an unethical way. Say a company is responsible for developing a safety-critical system and because of time-pressure falsifies the safety validation records. Is the engineer’s responsibility to maintain confidentiality or to alert the customer or publicise, in some way, that the delivered system may be unsafe?</para>
      <para id="id13360472">The problem here is that there are no absolutes when it comes to safety. Although the system may not have been validated according to pre-defined criteria, these criteria may be too strict. The system may actually operate safely throughout its lifetime. It is also the case that, even when properly validated, the system may fail and cause an accident. Early disclosure of problems may result in damage to the employer and other employees; failure to disclose problems may result in damage to others.</para>
      <para id="id10030724">The short version of the code summarizes aspirations at a high level of the abstraction; the clauses that are included in the full version give examples and details of how these aspirations change the way we act as software engineering professionals. Without the aspirations, the details can become legalistic and tedious; without the details, the aspirations can become high sounding but empty; together, the aspirations and the details form a cohesive code.</para>
      <para id="id13113780">Software engineers shall commit themselves to making the analysis, specification, design, development, testing and maintenance of software a beneficial and respected profession. In accordance with their commitment to the health, safety and welfare of the public, software engineers shall adhere to the following Eight Principles:</para>
      <para id="id11774227">1. PUBLIC: Software engineers shall act consistently with the public interest.</para>
      <para id="id13530196">2. CLIENT AND EMPLOYER: Software engineers shall act in a manner that is in the best interests of their client and employer consistent with the public interest.</para>
      <para id="id13219988">3. PRODUCT: Software engineers shall ensure that their products and related modifications meet the highest professional standards possible.</para>
      <para id="id14378379">4. JUDGMENT: Software engineers shall maintain integrity and independence in their professional judgment.</para>
      <para id="id8892830">5. MANAGEMENT: Software engineering managers and leaders shall subscribe to and promote an ethical approach to the management of software development and maintenance.</para>
      <para id="id10291720">6. PROFESSION: Software engineers shall advance the integrity and reputation of the profession consistent with the public interest.</para>
      <para id="id13075631">7. COLLEAGUES: Software engineers shall be fair to and supportive of their colleagues.</para>
      <para id="id2951129">8. SELF: Software engineers shall participate in lifelong learning regarding the practice of their profession and shall promote an ethical approach to the practice of the profession.</para>
      <para id="id13131929">You must make up your own mind in these matters. In this case, the potential for damage, the extent of the damage and the people affected by the damage should influence the decision. If the situation is very dangerous, it may be justified to publicise it using the national press. However, you should always try to resolve the situation while respecting the rights of your employer.</para>
      <para id="id14035267">Another ethical issue is participation in the development of military and nuclear systems. Some people feel strongly about these issues and do not wish to participate in any systems development associated with military systems. Others will work on military systems but not on weapons systems. Yet others feel that national defence is an overriding principle and have no ethical objections to working on weapons systems. The appropriate ethical position here depends entirely on the views of the individuals who are involved.</para>
      <para id="id13061922">In this situation it is important that both employers and employees should make their views known to each other in advance. Where an organisation is involved in military or nuclear work, they should be able to specify that employees must be willing to accept any work assignment. Equally, if an employee is taken on and makes clear that they do not wish to work on such systems, employers should not put pressure on them to do so at some later date.</para>
      <para id="id13641962">The general area of ethics and professional responsibility is one which has received increasing attention over the past few years. It can be considered from a philosophical standpoint where the basic principles of ethics are considered and software engineering ethics are discussed with reference to these basic principles.</para><para id="element-306">References :
</para><para id="element-171">http://en.wikipedia.org/wiki/Software_engineering,
http://cs.wwc.edu/~aabyan/435/intro.html, http://www.cc.gatech.edu/classes/AY2000/cs3802_fall/index.html, http://www.engin.umd.umich.edu/CIS/course.des/cis375/lectures/</para>
    </section>
  </content>
</document>